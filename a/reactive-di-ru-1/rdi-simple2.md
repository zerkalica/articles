# Биография

Юферев Сергей, фронтенд-разработчик QIWI.


Основные интересы: архитектура фронтенд-приложений, развивитие идей инверсии контроля (IoC) применительно к реактивному объектно-ориентированному программированию.

Много лет программировал на php. Карьера моя как php-программиста началась в 2005, а закончилась в 2012, за это время я успел увидеть, как с развитием языка от синглтонов  (code igniter, kohana, symfony1, zend1, yii) постепенно переходят к инверсии зависимостей и SOLID (symfony2, zend2, yii2, laravel).

А потом я начал писать приложение на js и понял как здесь много не хватает из привычных мне вещей. SOLID, DI на фронтенде и реактивность - это непаханое поле экспериментов. Примерно 2 года я развиваю идеи IoC и DI применительно к реактивному программированию, которые воплощаю в своей библиотеке: reactive-di.

# Как прекратить войну фронтенд-фреймворков

Цена использования любой хорошей практики программирования складывается из масштаба приложения и удобства реализации этой практики на текущем уровне развития языка и инструментов разработки: синтаксический сахар, наличие типизации, поддержки типизации в run-time, поддержки ide.

Я расскажу о "прибитости гвоздями" кода приложения к фреймворкам. Как популярные библиотеки заставляют нас писать непереиспользуемый код, делать ненужный рефакторинг и копипаст. О том, как не точно выбранная стратегия в начале пути, влияет на будущее фронтенд-разработки в целом.

Попытке решить эти проблемы в reactive-di, реализации идей внедрения зависимостей (DI) и реактивного программирования. Своего рода докера для кода, контролирующего состояние приложения и комбинирующего в себе идеи mobx, mol, cellx, angular2 di.

# Что получат слушатели

Узнают причину происхождения наболевших проблем с переиспользованием кода и как их решить. Как получить свободу от react-подобных библиотек, сохранив совместимость компонент с ide. Как использовать типизацию не только для проверки кода. Возможно, внесут ясность для себя в такие понятия как VDOM, компонент, dumb, smart.

# На кого ориентирован

На любых разработчиков фронтенд, сталкивающихся с проблемами переиспользования кода

# Краткое описание

Как популярные библиотеки заставляют нас писать непереиспользуемый код, делать ненужный рефакторинг и копипаст. И как решить эти проблемы развивая идеи DI на фронтенде. Дешевый SOLID. Ненавязчивая реактивность.

# Суть доклада

Раскрыть некоторые аспекты несовершенства архитектуры популярных решений для фронтенд разработки и упомянуть возможные пути решения на примере reactive-di: дешевый SOLID, ненавязчивая реактивность.

# Краткий план доклада

1. Эволюция архитектуры в php и как этот путь повторяется в javascript
2. Сильная связанность во всем, что касается компонент: React.createElement, React.Component, redux/store
3. Размытость понятия компонент: данные, поведение и верстка
4. Dumb и smart - или почему сложно переиспользовать smart
5. Redux - почему не всегда удобен путь actions first
6. Чем плохо центральное состояние и почему его сложно децентрализовать в redux, пути в redux-connect
7. Почему декораторы в js только маскируют сильное зацепление кода
8. Отсутствие простых решений для изоляции слоев кода ведет к framework lock-in
9. Как решаются эти проблемы. Клоны react: больше акцент на производительности, а не на архитектуру
10. Куча непереиспользуемых компонент (даже в рамках React) из-за прибитости к ним логики и способа работы с состоянием. 10 todomvc на react, vue, angular2, с redux, с mobx, с whatever
11. Почему SOLID так не любят в javascript - никто не знает как его сделать просто
12. Какие велосипеды изобретают из-за отсутствия инверсии зависимостей
13. Идеи angular2, почему он первый в этой области, но насколько дорогой ценой?
14. Как упростить работу с данными: ненавязчивые потоки или в чем успех mobx
15. mol, cellx, derivablejs. Линзы или как перенос lifecyle hooks из компонент в модели изменит мир
16. reactive-di - как дешево делать SOLID, изолировать код от способа менять состояние, способа взаимодействия с браузером и наметить путь к специфическим ORM на фронтенде

SOLID уточнить
Идея



## ЛНЛЧЛПВНВ

ЛНЛЧЛПВНВ: легко написал, легко прочитал, легко поменял, в ногу не выстрелил

### Легко написал

Низкий порог вхождения

Как достигнуть: отсутствие неоднозначностей, неродного для языка инфраструктурного кода (типы и babel хорошо), автоматизация (DI), ненавязчивость стримов (магические get/set, mobx)

### Легко прочитал

Бизнес логика как она есть, структуры, минимум переключений контекстов внимания и максимум сфокусированности на задаче.

Как достигнуть: контракты, домены, иерархия, принципы навигации, анализаторы связей интерфейсов с реализациями.

### Легко поменял

Простая заменяемость частей без рефакторинга бизнес-слоя

Как достигнуть: SOLID, слои, контракты, слабой связанностью частей через интерфейсы и вынесением связей с рализациями в отдельный слой (composition root). Рефакторинг composition root не требует новых тестов.

### В ногу не выстрелил

Когда в run-time возможны только логические ошибки. Безопасность кода на типах.

Как достигнуть: Выбрать правильный язык, экосистему и инструменты статического анализа

## Причины войны

Война или конкуренция, это когда из-за "прибитости" к компонентам логики и способа работы с состоянием мы имеем 10 todomvc на react, vue, angular2, которые в браузере выглядят одинаково и делают одно и то же. Даже в рамках React: с redux, с mobx и пр.

### Монолиты всюду

1. Пхп, как закончилась эпоха синглтонов, от Kohana к Symfony2
2. Не модульный React или как заменить vdom на realdom, а SyntheticEvent на RealEvent, отделить хуки, propTypes, context
3. Грязные чистые компоненты с JSX или как отвязаться от React.createElement
4. Первые реализации FLUX или как синглтоны помогли огрести с изоморфностью
5. Немного про Inferno. Модульность для экономии кода, но не для расширения
6. Синглтоны делают невозможной контейнеризацию кода

### Компонент - функция, которая не функция

1. Хорошая идея. html в виде композиции функций. Корневая функция - это страница, аргументы функции - свойства всех html-тегов.
2. f(state) === VDOM - идея декларативной верстки не всегда работает. VDOM срабатывает поздно - перед браузером
3. VDOM - кэш, временное решение, т.к. браузеры пока отстают от требований рендеринга UI
4. Быстро, но не очень. Проблемы с производительностью: добавили shouldComponentUpdate, переложив задачу оптимизации на ручной труд программистов
5. 100% кастомизируемость - удобно выдеять в сторонние компоненты, но это дает много свойств в корневом компоненте

### Ввели состояние в компоненты

1. Состояние - как часть логики размазали по компонентам, добавив setState
2. Свойств все-равно много, еж. Добавили react-context. В корневом компоненте описали что прокидывать, в дочерних описали, что ожидаем, получили страшный react-only dependency injection
3. setState может быть замаскирован: redux-connect, mobx-connect, redux-reselect
4. Компонент с хуками провоцирует на прибивание логики к верстке, что ведет к непереиспользуемости. Например, componentDidMount вынуждает рассказать компонентам о способе получения данных: явно писать код вызова загрузки, fetch, subscribe, unsubsribe. Даже если этот вызов замаскирован слоями redux/mobx. Нет неявного способа актуализации данных по факту рендеринга компонента. А если одна модель используется в нескольких компонентах, в каждой актуализировать?
5. Компоненты-классы содержат логику, управляют данными, реализуют контексты, накладывают ограничение на конструктор и варят вам кофе

### Dumb или presentational. Показушные компоненты

1. Может содержать верстку и стили, без зависимостей от сторонних либ
2. Без состояния, pure, кастомизация их только через свойства. Иногда, для очень мелких задач setState допускается
3. Логика может быть, но работающая как фильтр
4. Пример: Page, User, List
5. 100% кастомизируемость, но много свойств
6. Переиспользуемый

### Smart или container. Поведенческие компоненты

1. Без generic html-верстки и стилей, но содержат Dumb и другие Smart. Т.е. все-равно есть композиция компонент
2. Есть состояние. Работает с данными через setState, flux, redux, mobx, relay
3. Логика реакции на колбэки и работы с состоянием
4. Пример: UserPage, PaymentList, FollowedUserList, ReactRouter, ReactSideEffect, Helmet
5. < 100% кастомизируемость
6. Не переиспользуемый. Если UserPage вдруг понадобился в другом проекте, придется копипастить, т.к. прибит к состоянию, внутри композиция компонентов

### Итог

1. Есть компоненты только с версткой, компоненты с логикой поведения, данными и чуть-чуть версткой
2. Иначе, HMVC на компонентах, размазанное по верстке, с разделением, которое плохо, но отделяет MC от V
3. Что же такое компонент, почему логика и данные вообще имеет отношение к компонентам
4. Проблемы начались, как только ввели состояние
5. Следствия: куча непереиспользуемых компонентов (даже в рамках React) из-за прибитости к ним логики и способа работы с состоянием. 10 todomvc на react, vue, angular2, с redux, с mobx, с whatever
6. vue, inferno, preact, ivi, bobril, vidom, dio, deku, тысячи их. Гонка бенчмарков: кто напишет наиболее быстрый на синтетических тестах react-clone

### FLUX

1. redux - Shut up and take my state changes. БД нужна, но не ценой навязывания одного способа менять состояние. Работая с git, мы не пишем ``` {type: 'Добавить строчку', pos: 34, text: 'bla-bla'} ```, мы просто меняем файлы. Redux заставляет менять состояние, используя sed и cat. В redux первичны транзакции
2. Много сторов или мало
3. Селекторы redux-reselect или redux-connect - центральне состояния и селекторы к нему, аналог CSS селекторов к документу. В рамках компонент - антипаттерн
4. Много arrow, а производительность в слое данных важна, скажем на сервере
5. Изолированность reducer дорогой ценой - нет интерфейсов
6. Dispatcher - это ServiceLocator. Вызов функции, middleware в ООП решается аспектами и DI
7. Stores. паттерн-матчинг на switch/case. Лень писать БД, пусть часть ее напишут другие в виде stores. Stores должны быть отдельной библиотекой: пример react-derivable
8. Атомарность изменений на уровне state, а не свойства, необходимость shallowEqual и создания копии объектов, версионирования
9. В коде должны быть еще и промежутки. Но тогда эти промежутки заполнятся зоопарком плагинов, делающими одно и тоже разными способами. Т.к. конечная цель - написать приложение, а не базу данных
10. Цельность vs универсальность. Нету цельной основы для построение приложения, как angular2, а есть 100500 бибикающих starter kit ов
11. Есть куча todomvc, но мало полноценных примеров приложений с persistence, обработкой статусов, принципами построения приложения, модульностью, как в angular2 ng-modules и т.д.

### О Middlewares

1. Замена явного неявным: вместо прямых вызовов функций - конвеер, который с доступом к одному объекту
2. Ручные зависимости. Результат зависит от последовательности применения
3. Запутанность асинхронных middleware, раскрутите пример из redux

### Нет общего подхода для контейнеризации кода

1. React сontext - в одном месте регистрируем что-то, в другом описываем что хотим получить - DI
2. redux thunkify - di для бедных
3. hmr: react-hotloader, redux-hotloader, whatever-hotloader костыли из-за отсутствия di
4. Hapi - описали зависимости в плагинах, осталось только признаться, что это di
5. Типизация для работы di. Робкая попытка использовать типы в runtime в inversify, angular2 и typescript. Нету метаданных для интерфейсов, как значений. angular2 - Центральная идея DI
6. В js/flow/babel c типизацией и метаданными все ок, есть только инертность мышления, не позволяющая в полной мере ее использовать и создать соотвествующие стандарты

### Разные решения для фронтенда

Есть 2 типа решений - развитие идей ФП и ООП. Они игнорируют опыт друг друга.

#### Для данных

1. graphql - хорошо, а relay/apollo - плохо или продолжаем прибивать базу к компонентам
2. RxJs - навязываем потоки, где нужно и не нужно
3. Derivable, удобное апи, но течет и заброшен, не pull, 2015 г.
4. Mobx - не pull, цена ненавязчивости или как усложнить сериализацию mobx-объектов
5. Mol - но слишком не похож на привычные вещи, с нуля написана вся экосистема, включая модульную систему
6. Cellx - pull-архитектура, но пока не di, не такой ненавязчивый как mobx

Последние 4 выполняют много работы по оптимизации данных, делая большую часть VDOM оверхедом

#### react-подобные

1. [preact][preact] - мелкий react, базовый класс
2. [inferno][inferno] - быстрый react, базовый класс
3. [vue][vue] - монолит, framework lock-in
4. [choo][choo] - легковесный, прибит к template-strings шаблонам
5. [deku][deku] - jsx-based, прибит к redux
6. [rionite][rionite], базовый класс, прибит к template-strings
7. [matreshka][matreshka] - монолит, framework lock-in

#### ФРП на стримах

1. [cycle][cycle] - ФП
2. [funnel][funnel] - ФП
3. [recycle][recycle] - ФП, додумались props и state передавать вместе

### Хороший фреймворк, если

1. Компоненты только функции без состояния
2. Состояние не центральное, в виде моделей
3. Компоненты не знают как получено состояние: mobx, redux или еще как-то
4. Модели связываются между собой и с внешним миром только через изолированный слой хуков

## Итог. Общие болячки экосистемы JS

* Framework Lock-in. Подходы, делающими приложения зависимыми от библиотек, а не интерфейсов
* Синглтоны, увеличивающие [зацепление][couple] и делающие код нерабочим в многопользовательских окружениях
* Размытие понятия компонента, слишком много отвественности
* Навязчивость подходов: react, redux

Компоненты - нужно разделить на движки для рендеринга и движки для описания формы компонента

## Проблема

## reactive-di позволяет

* Делать все JSX-компоненты 100% чистые, без состояния, только с версткой
* Убрать зависимость от React.createElement - можно адаптировать под много фреймворков без пересборки
* Уменьшить знание приложения о способе получить состояние и записать его. Убрать прямую зависимость от [mobx][mobx], [cellx][cellx], [derivable][derivable], [redux][redux] и подобных
* Отказаться от центрального состояния и селекторов к нему
* Сохранить поддержку flow и typescript для компонент и стилей, а не только классов и функций
* Абстрагировать компоненты от факта получения данных и от того как, получены данные - через конфиг, rest api или еще как-то
* Привнести в мир React-подобных иерархический DI из ангулара 2, только проще
* Отказаться от VDOM, т.к. rdi большую часть операций с состоянием оптимизируется на самом верху - в данных

Далее скорее всего не влезет в первый доклад


## Про что же reactive-di

про то, как ...

1. писать код слабо завязанный на окружение: browser, server, redux, mobx, react, inferno
2. развить идеи di на компоненты: контексты, внутренние свойства компонента
3. представить центральное состояние в виде изолированных моделей
4. Отразить жизненный цикл компонента на модели: убрать хуки из компонента и перенести эту логику поближе к данным
5. Автоматизировать вычисление error/pending/complete из любой части приложения, которая прямо или косвенно зависит от моделей
6. Абстрагировать прикладного программиста от транзакций
7. Контейнеризовать код и состояние: иметь возможность делать для части компонент отдельный стейт, наследующий родительский

### Основные принципы

1. Отсутствие низкоуровневого кода в приложении и минимизация инфраструктурного кода
2. Весь инфрастуктурный код сосредоточен в lifecycle events моделей
3. DI на метаданных от типизации
4. Жесткие связи преобладают над связями через интерфейсы
5. Метаданные к связям генерируются средой сборки
6. Регистрация зависимостей автоматическая на основе жестких связей
7. Можно просто сделать жесткую связь нежесткой, отрефакторив интерфейс, с возможностью регистрации в composition root
8. Composition root иерархический, в компонентах, регистрация в нем только нежестких связей

### Композиция

1. Приложение - композиция функций преобразования состояния: f(data)
2. Чистые функции без контекста не бывают, все надо настраивать: createStore, createButton(Ok) => createGreenOkButton(green): GreenOkButton.
3. Для избежания дублирования параметров, в коде не используется Button(Ok, Green), а используется GreenOkButton
4. Аргументы функций делим на 2 группы, первые передаем в момент вызова, остальные - контекст, которые прибивается к функции в момент первого к ней обращения
5. Использовать синглоны и глобальные объекты - не вариант, нужна возможность переопределить любую сущность на любом уровне вложенности динамически, в любой момент времени. Используем функциональный подход.
6. Считаем что приложение крутится на сервере, а много пользователей просто вытаскивают его к себе в DOM. На этом же сервере для каждого пользователя есть общий стейт и свой локальный стейт.
7. Ручная композиция всего приложения в точке входа позволяет как угодно сконфигурить сторонние компоненты: App(user1State, Button(Ok), Button(Cancel), SomeDialog(Bla-bla)) И для каждого создать версию App со своим стейтом
8. От ручной композиции переходим к DI: извлечение информации о зависимостях из сигнатур функций и конструкторов классов
9. Проецируем опыт DI на компоненты: упрощаем compose до Component(props, context), где context - зависимости, которые автоматически вставит DI при вызове
10. Продолжаем делать компонент чистым: Component(props, context, createElement). Эта форма компонента будущего.
11. Скоупы (providers в component decorator из angular2). А что если начиная с любого узла в дереве функций, из которых состоит приложение, у нас будет возможность определить синоним GreenButton -> BlueButton

### Состояние

1. Прикручиваем к этому всему состояние: добавляем модели, которые могут инжектироваться в сервисы и компоненты (аналог value providers из angular2)
2. Но добавляем в модели еще один слой для их изменения: get/set
3. Используем принцип линз для выполнения логики при записи и при чтении в модель: pull(oldModel): newModel, put(model): newModel
4. Добавляем поддержку асинхронности: pull(): Promise<NewModel>, put(model: NewModel): Promise<NewModel>
5. Добавляем механизм извлечения статуса getStatus(model): pending | complete | Error
6. Остаются привычные классы-сервисы с методами-редюсерами, но их состояние не замкнуто на них самих, они управляют состоянием всего приложения через модели с линзами, которые @vintage с habra называет атомы
7. Возвращаемся к примеру с пользователями и состоянием на сервере для всех и каждого.
8. А что если начиная с какого-либо узла поддерево получит свою копию стейта, но не deep-copy: UserModel останется в App(SessionModel, UserView(UserModel, SessionModel))
9. Пример: на сервере есть Logger, одинаковый для всех запросов (контекст приложения). И UserSession, уникальный для пользвателя от которого пришел запрос (контекст сессии). И MyTodoList, уникальный для страницы (контекст страницы).
10. В область видимости высшего входят низшие Page(Session(App))
11. Оптимизация. Рендеринг - "схлопывание" лишних обновлений в DOM или как VirtualDOM стал почти оверхедом
12. Размер кода rdi 36 кб vs 52 mobx

### Итог

1. IoC для управления асинхронными зависимостями: маппинг стейта на классы и компоненты
2. pull или data-flow архитектура, линзы (идеи $mol_atom и cellx)
3. Универсальные JSX-компоненты без зависимостей от React и без деления на stafeull и stateless, dumb и smart
4. В любой месте дерева может быть создан новый контейнер с контекстом
5. reactive-di не исключает redux, но транзакции и версионирование не всегда нужны

### Планы на будущее

1. Много примеров кода для частных случаев
2. Документация
3. Улучшение апи хуков для управления состояниям. Что б можно было проще интегрировать в rdi решения вроде swarm
4. Оптимизация коллекций
5. HMR, timetravel
6. Замена react/inferno на real dom bel
7. Логи с подробной трассировкой экшенов: ответ на вопрос не только что изменилось, но и кто изменил
8. Адаптация redux devtools
