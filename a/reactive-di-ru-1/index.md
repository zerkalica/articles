# reactive-di

Хочу рассказать об одной своей js-библиотеке для реактивного программирования (reactive-di), которая идейно близка к mobx, cellx, $mol_atom, но основана на развитии идей инверсии контроля и внедрения зависимостей.

reactive-di это:

1. SOLID и DI: Типизация, как источник метаданных для разрешения зависимостей, код с минимумом util-мусора, шаблонных конструкций, декораторов, объявление зависимостей без регистрации кучи метаданных, скоупы как в angular2
2. Как прекратить войну фреймворков: отсутствие зависимостей от реализаций view-библиотек в коде (React, Inferno и пр.), компоненты с нулевыми зависимостями, совместимые с ide (проверка типов свойств компонета, автокомплит и т.д.)
3. Реактивность: pull-архитектура, линзы (идеи $mol_atom и cellx)
4. Отсутствие специфичных для реактивных библиотек, оберток над данными в коде: по возможности оставить только модели, компоненты и сервисы с бизнес-логикой. Обертки только при общении с сервером Promise, Observable и при записи данных в модели: get/set/then/catch
5. Код с минимумом util-мусора, шаблонных конструкций, декораторов, без слоя конфигурации контейнера DI.
6. Апи для мониторинга изменения состояния

Раньше я много лет программировал на php. В общем то карьера моя как php-программиста началась в 2005, а закончилась году в 2011, за это время я успел увидеть, как с развитием языка от синглтонов  (code igniter, kohana, symfony1, zend1, yii) постепенно переходят к инверсии зависимостей и SOLID (symfony2, zend2, yii2, laravel). Я считаю, что по мере усложнения задач, все языки, рано или поздно проходят похожий путь.

Когда мы говорим паттерн или лучшая практика проектирования, то следует учитывать контекст, где она лучшая. Например, паттерн синглтон был самым популярным в php до symfony2 (а многие скажут, что и до сих пор) из-за своей простоты, т.к. кроме конструкций языка, сторонних библиотек использовать было не нужно. Однако из-за сильной связанности и невозможности подменить без костылей один синглтон на другой (зависимость то прямая), без шаблонного кода и без скатывания в говнокод рано или поздно не обойтись. Т.е. целесообразность использования паттерна зависит не только от решаемой задачи, но и от масштаба приложения, и уровня развития языка (типы, рефлексия).

Наверное многие, кто программировал на зрелых с++ подобных языках, вроде java, c#, php, знают что такое SOLID, ну или по крайней мере буква D в этой аббревиатуре.

D - Dependency injection или внедрение зависимостей, некая универсальный фабрика. Т.е. вы создаете класс, а все его зависимости передаете в конструктор, описывая их в виде интерфейсов. А специальная библиотека (Spring DI в Java, Ninject в C#, Symphony2 DI в php), при запросе данного класса через нее, автоматически распознает эти зависимости, настраивает и перередает в конструктор.

Вынесение знания о том, как создать тот или иной экземпляр класса в отдельный слой приложения - это инверсия контроля. DI - механизм реализации этой инверсии. Этот подход применим не только к классам, но и к функциям, если те порождают другие функции (замыкания).

Суть проблемы в том, что почти любой класс, объект с методами, функция в приложении требует предварительной настройки.
Можно сделать один статический класс или объект с настройками и импортировать его в каждом модуле, где нужны настройки. Но этот путь плох сильным зацеплением кода - многие части кода получают знание о конкретном объекте с данными. Потом нельзя без рефакторинга для одной части кода сменить одни настройки на другие, не затронув остальной код.

Поэтому все хорошие библиотеки экспортируют либо функции-фабрики (redux), либо классы. В точке входа в приложение эти классы инициализируются и связываются. Говоря иначе, основной код приложения, там где находится бизнес-логика, ничего не знает об инициализации своих частей, а знание об этом выносится в отдельный слой.

Это делает части приложения легко настраиваевыми, заменяемыми и интегрируемыми в каркас DI, а также более пригодными для unit-тестирования. Важно не сколь удобство тестирования, сколь именно вынесение знания о прямых зависимостях из основного кода в отдельный слой и автоматизация создания классов.

Т.е. если до изобретения Di писали так (Примеры кода здесь и далее я буду писать на js+flowtype):

```js
// a.js
export default {
    methodA() {
        return 1
    }
}
```

```js
// b.js
import a from './a'

export default {
   methodB() {
       return 2 + a.methodA()
   }
}

// b.methodB()
```

То после, стали писать так:

```js
// A.js
export interface IA {
   methodA(): number;
}
export default class A {
   methodA() {
      return 1
   }
}
```

```js
// B.js
import type {IA} from './A'
export default class B {
   _a: IA
   constructor(a: IA) {
      this._a = a
   }
   methodB() {
      return 2 + this._a.methodA()
   }
}
```
Что, ценой небольшой избыточности, дало возможность убрать прямую зависмость b от a, перевести ее на менее сильную - интерфейс IA.

Есть еще одно понятие, не связанное с DI - это реактивность. Когда есть объект с данными (atom, cell, источник, source, mobx property, observable) и его свойства можно не только читать, но и подписываться на изменения в них. А также есть потребители этих данных и изменений в них (потребитель, consumer, observer, component), например компоненты react. И при изменении данных, происходит какое-то действие - к примеру перерисовка компонента. Кроме этого есть еще промежуточные звенья (computed, derivable, вычисляемая ячейка) - которые стоят на пути от источников к потребителям и преобразуют или комбинируют данные из нескольких источников в нечто более удобоваримое для потребителей.

Такой принцип используют много библиотек, их можно разделить на 2 лагеря: те, кто-то поближе к ООП (mobx, cellx, derivablejs, $mol_atom), а кто ближе к ФП (rxjs, beacon, kefir). Первые имеют более простой апи и стремятся как можно меньше использовать оберток-функций между бизнес-логикой и данными. Вторые - наоборот, все заворачивают в функции, протекая в большинство слоев приложения.

Есть еще связанные с этим понятия push (control-flow) и pull-архитектуры (data-flow). Пусть есть observable-данные: атом ($mol_atom) или ячейка (cellx) или объект mobx и есть компонент, который использует эти данные. Изначально, при первой прорисовке компонента, данные не актуальны, т.е. их надо загрузить с сервера. Вопрос, где размещать связанную с загрузкой логику?

Push - загрузка происходит в хуке componendDidMount компонента, в большинстве фронтенд приложений так и делают.
Pull - сама модель имеет аналогичный хук pull и любой компонент, который первый запросил эту модель, вызовет этот хук. Т.к. одну и ту же модель могут использовать разные компоненты, то такой перенос логики поближе к модели уменьшает дублирование кода. Один раз написав модель с таким хуком, мы больше не задумываемся, актуальны данные в модели или нет - модель сама себя актуализирует, когда нужно. Аналогично подход работает и для сохранения данных.

Принцип этот чем-то похож на линзы.

Более подробно см. статьи @vintage и @Riim на хабре.

Я пытаюсь развить идею реактивного внедрения зависимостей. Мои эксперименты - это попытка использовать внедрение завимостей не только для управления инициализацией классов, но и для управления реактивностью внутри приложения. Если решения вроде mobx, cellx, $mol_atom - это реактивные обертки над данными внутри  кода приложения, то мой подход - это бизнес логика внутри реактивных оберток, состоянием которых управлет контейнер DI и которые в коде приложения никоем образом не видны, по крайней мере тогда, когда дело касается чтения данных.

reactive-di это:

1. SOLID и DI: Типизация, как источник метаданных для разрешения зависимостей, объявление зависимостей без регистрации кучи метаданных, скоупы как в angular2, Код с минимумом util-мусора, шаблонных конструкций, декораторов
2. Компоненты: отсутствие зависимостей от реализаций view-библиотек в коде (React, Inferno и пр.).
3. Как прекратить войну фреймворков: компоненты с нулевыми зависимостями, совместимые с nuclide и аналогичными ide (проверка типов свойств компонета, автокомплит и т.д.)
6. Реактивность: pull-архитектура, линзы (идея от $mol_atom, cellx)

4. Отсутствие специфичных для реактивных библиотек, оберток над данными в коде: по возможности оставить только модели, компоненты и сервисы с бизнес-логикой. Обертки только при общении с сервером Promise, Observable и при записи данных в модели
5. Код с минимумом util-мусора, шаблонных конструкций, декораторов, без слоя конфигурации контейнера DI.
7. Апи для мониторинга изменения состояния

## Немного критики

Далее я пытаюсь озвучить то, что на мой взгляд тормозит развитие SOLID на js, почему reactive-di не велосипед. Какие недостатки экосистемы я старался исправить.

Про почти всю экосистему js можно сказать одной фразой: "прибито гвоздями" или framework lockin. Вот про c#, java, php нельзя, ибо широко используются DI, SOLID, где DI - это лишь клей для кучи сторонних библиотек. Сложная задача, обычно оформляется в виде сторонней библиотеки, а потом под конкретный фреймворк, например Spring, пришется слой интеграции.
Попробуйте redux-приложение заставить работать, скажем, под mobx, слишком сильно перемешана бизнес-логика с спечифичными конструкциями и подходами этих библиотек.

В php типы повились за пару лет до того как я завязал с ним. За это время в нем были созданы или (правильнее сказать переосмысленны java-решения) множество библиотек и фреймворков, сильно использующие и типизацию и аннотации (декораторы), DI и SOLID, интеграцию с ide, где был возможен рефакторинг и много других плюшек, которые дает типизация.

А когда был создан typescript? И только сейчас, с большим опозданием, чуть ли не насильно, продвигается angular2-4. Говорить о целесообразности этого подхода для js не цель этой статьи, но я уверен, что с усложнением задач, не зависимо от предметной области, все придет к SOLID или чему-то похожему, язык тут имеет второстепенное значение. Angular2 это первая и единственная ласточка (или даже франкенштейн), но это сравнительно полноценный фреймворк и привесенные в него идеи - новые в мире frontend. Здесь экосистема js только начинает свой путь в зрелость.

### Компоненты

Нет универсальных компонент, а есть война компонентов (react, vue, angular, etc). Эти популярные библиотеки завязываются не на интерфейсы, а на реализации. Поэтому нельзя без костылей, вроде подмены модулей в webpack, сменить реакт даже на inferno. Есть конечно попытки исправить ситуацию, вроде substack/hyperx. Но, в любом случае компоненты - функции не без внешних зависимостей (внутри React.createElement или Inferno.createElement h-функция или что-то еще)

Или взять спецификацию Jsx. Jsx прибит к реакту, даже если не использовать extends React.Component. Jsx преобразуется в дерево вызовов React.createElement. Если пошаманить с babelrc, то можно завязаться на любой другой createElement, но связь статическая, без пересборки, такой компонент не адаптировать к другому фреймворку.

Достаточно добавить еще один аргумент в чистый компонент и вот компонент с нулевыми зависимостями от внешних фреймворков:

```js
function MyComponent(props: Props, h: CreateElement) {
   return <div>...</div>
}
```

Про стили аналогично, только тут проблема усложняется тем, что есть статические сборщики sass, less и есть динамическая генерация css: jss, typestype, со всеми плюсами и минусами, которые описывать можно в отдельной статье. Но суть одна, для последних нет общепринятой спецификации, точнее есть cssx, но он не является настолько популярным (точнее в него не вкладывали столько ресурсов), как jsx, и каждый библиотекописатель городит свой внешний вид js-to-css.

### Про типизацию

Тут все просто. React прибит к flowtype через jsx intrinsic, angular2 прибит к typescript (поддержка типов в шаблонах). Т.е. разработчики "компиляторов" прибивают гвоздями попсовые фреймворки к компиляторам, т.к. нет общепринятых спецификаций этих компонент, а есть конкретные реализации у react, vue, angular2 и кучи других.

Системы типов сильно помогают в js, но и они не полноценны, например, как получить сигнатуру интерфейса в runtime (скажем, ninject в c# использует эту возможность, а inversify в js может сопоставить интерфейс с классом только через строковые ключи)? Для flow/babel еще можно придумывать babel-плагины, которые сделают из

```js
interface IA {}

class A implements IA {}

di.register((_: IA), A)
```

нечто такое:

```js
interface IA {}

class A implements IA {}

di.register('2oirj9i32jr8u3ruh32', A)
```

Но конструкция ``` (_: IA) ``` костыль, нет в js способа получить интерфейс как значение (как есть в c# или java), т.к. нет стандартов.

### Декораторы

Декоратор только маскирует связанность, но не уменьшает ее, т.к. зачастую декоратор не просто дописывает метаданные к классу (как оно должно быть), это здоровенная функция с кучей логики (react-connext в redux, mobx-react, observable в mobx и т.д.), которая меняет поведение класса или свойства.
Вызов декоратора, если убрать сахар с собачкой, чем-то напоминает ``` React.createClass({bla-bla}) ```
В новой спецификации декораторов хотели даже убрать возможность прямого доступа к классу или свойствам, но не решились.
В пхп эти самые декораторы вообще писались как комментарии в коде и без препроцессора, никак не могли повлиять на поведение класса. Я считаю, что задача декоратора - только добавлять метаданные.

В этой статье я эту тему развивать далее не буду, т.к. считаю, что все это кризис взросления экосистемы и носит временный характер. Сосредоточусь на reactive-di.

## Основы

## Источники

Source или

## Компоненты

В reactive-di нету деления на dumb и smart, все компоненты единообразны. Это чистые функции, без статических зависиостей от чего либо, содержащие только jsx-верстку. Сигнатура функции - интерфейсы свойств (props) и состояния (state), а также h-функции (createElement).

```js
// @jsx h
import {UserService, CurrentUser} from './srv'

interface UserProps {
  id: string;
  name: string;
}
interface UserState {
  userService: UserService;
}


function User(props: UserProps, state: UserState, h: Function) {
  return <button onClick={() => state.userService.onClick(props.id)}>{props.
     name}</button>
}
```

Вне DI его можно использовать, адаптировав, например к react:

```js
import React from 'react'
import User from './User'

export default UserReact extends React.Component {
   constructor(props: Props) {
      super(props)
      this.state = {}
   }
   render() {
      return User(this.props, this.state, React.createElement)
   }
}
```

Di автоматизирует создание подобных оберток. Разделение свойств на props и state необходимо для нормальной поддержки в ide, т.к. state - внутренние свойства, которые ide не должна подсказывать при использовании User в jsx.

При использовании Jsx, 3й аргумент, h, можно не писать, а его подстановку переложить на babel-плагин, который определяет все функции с jsx внутри и генерирует код с этим аргументом.

Было:

```js
function User(props: UserProps, state: UserState) {
  return <button onClick={() => state.userService.onClick(props.id)}>{props.
     name}</button>
}
```

Стало:

```js
function User(props: UserProps, state: UserState, h: Function) {
  return <button onClick={() => state.userService.onClick(props.id)}>{props.
     name}</button>
}
```

Это не очень чистое решение, зато уменьшает кол-во ошибок, т.к. h-аргумент явно не используется и его можно забыть написать. Дело в том, что jsx проектировался без учета того, что на этапе сборки createElement может быть не известен, а становится известным только в runtime, перед выполнением рендеринга компонента. Более того, функция createElement может быть разной, для разных компонент (может содержать контекст или быть от другого фреймворка)
