# Биография

Юферев Сергей, фронтенд-разработчик QIWI.

Опыт разработки на javascript: 4 года

Основные интересы: архитектура фронтенд-приложений, развивитие идей инверсии контроля (IoC) применительно к реактивному объектно-ориентированному программированию.

Много лет программировал на php. Карьера моя как php-программиста началась в 2005, а закончилась в 2012, за это время я успел увидеть, как с развитием языка от синглтонов  (code igniter, kohana, symfony1, zend1, yii) постепенно переходят к инверсии зависимостей и SOLID (symfony2, zend2, yii2, laravel).

А потом я начал писать приложение на js и понял как здесь много не хватает из привычных мне вещей. SOLID, DI на фронтенде и реактивность - это непаханое поле экспериментов. Примерно 2 года я развиваю идеи IoC и DI применительно к реактивному программированию, которые воплощаю в своей библиотеке: reactive-di.

# reactive-di - как прекратить войну фронтенд-фреймворков

Я расскажу о reactive-di - библиотеке для реактивного объектно-ориентированного программирования в ключе SOLID, которая идейно близка к mobx, cellx, $mol_atom, но основана на развитии идей инверсии контроля (IoC) и внедрения зависимостей (DI).

Reactive-di решает следующие проблемы:

* Сильная сцепленность или "прибитость" кода с бизнес логикой приложения к конкретным библиотекам для рендеринга: JSX к createElement, CSS в JS к JSS-подобным или к библиотекам управления состоянием: (store, dispatcher, action в flux-подобных)
* Захламление кода сложными обертками над данными, вроде rxjs, вместо использования высокоуровневых абстракций, вроде mobx. (Здесь reactive-di идейно похож на mobx)
* Проблему точек расширения: DI дает возможность заменить любую модель, сервис или компонент на другую реализацию с таким же интерфейсом на любом уровне вложенности приложения без рефакторинга и пересборки
* Управления состоянием
* Областей видимости: DI позволяет клонировать состояние для поддерева компонентов (providers в component декораторе в angular2)

Cледование принципам SOLID - остается сложной задачей в разработке на javascript и даже flow/typescript. Цена использования любой хорошей практики проектирования складывается из масштаба приложения и удобства реализации этой практики на текущем уровне развития языка программирования и инструментов разработки: синтаксический сахар, наличие типизации, рефлексии, поддержки ide.

Reactive-di - цельное решение, которое позволяет, оперируя понятиями модель, сервис и компонент с минимумом util-кода, писать реактивные фронтенд-приложения без привязки к конкретным реализациям библиотек (react, mobx, redux, jss). В отличие от mobx, где для связывания источников данных, вычисляемых значений и компонент используются формулы, reactive-di использует для этой цели принципы инжекции зависимостей.

Доклад затронет следующие темы:

* Зачем SOLID и DI в javascript и какие они должны быть на frontend
* Связывание частей приложения на основе метаданных или чего не может typescript
* Как использовать инверсию контроля (IoC) для управления реактивностью
* pull или data-flow архитектура, линзы (идеи $mol_atom и cellx)
* Универсальные JSX-компоненты без зависимостей от React и без деления на stafeull и stateless, dumb и smart
* JS-to-CSS: реактивный css без прямых зависимостей от jss, typestype, aphrodite и т.д.

Доклад больше ориентирован на фронтенд-разработчиков, знакомых с Angular2 и Inversify или писавших на таких языках как PHP (Symfony2), C# (Ninject) или JAVA (Spring).

# План доклада:

1. Что такое SOLID и DI и зачем он нужен во фронтенд разработке: чем выше абстракция, тем хуже SOLID
2. Почему SOLID не популярен в js-разработке: ура, типы есть, но нет стандартов для метаданных и рефлексии, как быть с интерфейсами
3. DI. Как DI позволяет уйти от "прибивания гвоздями" на всех уровнях приложения
4. DI. Какую цену надо за это заплатить, почему не годится копирование известных бэкенд-решений
5. DI. Автоконфигурирование: flow и typescript типизация, как источник метаданных для разрешения зависимостей
6. DI. Что такое иерархический DI (идея providers из angular2)
7. Состояние. DI для управления состоянием через модели-зависимости: sources, computed, consumers
8. Состояние. Маппинг конфигурации приложения в модели, code-first
9. Состояние. Мониторинг состояния приложения
10. Состояние. Создание различных оберток-сеттеров над моделями для использования в компонентах
11. Lifecycle. Что такое pull и push-архитектура
12. Lifecycle. Отражение жизненного цикла компонента в моделях: merge/pull/put, линзы (идеи $mol_atom и cellx)
13. Асинхронные операции. Как через Promises и Observables обновлять состояние моделей
14. Асинхронные операции. Как "вытаскивать" статус и ошибки загрузки из моделей без прямого к ним доступа из компонента
15. Асинхронные операции. DI для извлечения информации о статусе загрузки
16. Компоненты. Как сделать компоненты с нулевыми зависимостями. Написание babel-plugin а, который распознает компоненты и добавляет к ним метаданные.
17. Компоненты. Разделение отвественности: только верстка, компонент не управляет состоянием и не содержит бизнес-логики.
18. Компоненты. Каждый компонент может создавать свою копию DI (контекст), наследую состояние родительского
19. Стили. Как опыт с компонентами распространить на стили: описание стилей с нулевыми зависимостями от js-to-css библиотек
20. IDE. Code first или как сохранить поддержку типов в существующих ide для классов, функций, стилей и свойств компонент
21. Оптимизация. Отсутствие генерации функции, оптимизация коллекций, от React.createElement к Inferno.createVNode
22. Оптимизация. Рендеринг - "схлопывание" лишних обновлений в DOM или как VirtualDOM стал почти оверхедом
23. Планы на будущее: оптимизация коллекций, hmr, timetravel, замена react/inferno на bel и raw DOM.
